{"title":"Data Wrangling Basics","markdown":{"yaml":{"title":"Data Wrangling Basics","subtitle":"Data Wrangling Day 1","author":"Brian Gural, Lorrie He, Justin Landis, JP Flores","format":{"html":{"toc":true}}},"headingText":"What is data wrangling?","containsRefs":false,"markdown":"\n\n\n-   Data wrangling, manipulation, or cleaning is the process of transforming data into a format that is more suitable for analysis. This can include removing missing values, changing the format of data, or combining multiple datasets.\n\n-   There's rarely a single way to approach any given data-wrangling problem! Expanding your \"toolkit\" allows you to tackle problems from different angles.\n\n## Objectives of Data Wrangling: Class 1\n\n- Be comfortable subsetting vectors and dataframes using both base R and tidyverse functions\n\n- Understand what tidy data is and what it looks like\n\n- Understand piping basics\n\n::: {.callout-note title=\"Measure twice, cut once\"}\nBefore you begin wrangling data, you should be able to:\n\n-   Define how you want the data to look and why\n\n-   Document it well so that others (and future you!) know what you did\n\n-   Know what tools you have and how to use them\n:::\n\n## Building a toolkit\n\n### Working with vectors\n\nPulling out specific parts of a data set is important when analyzing with R. **Indexing**, or accessing elements, subsets data based on numeric positions in a vector. You may remember this from the first class. Some things to be aware of when indexing:\n\n-   Indexing uses brackets. i.e. the 5th element in a vector will be returned if you run `vector[5]`.\n\n-   It's helpful for getting several elements at once, or reordering data.\n\nHere are some examples:\n\n```{r}\n# First, we'll make a vector to play with\nnames <- c(\"rosalind\", \"marie\", \"barbara\")\n```\n\n```{r}\n# if we print the output, we'd get:\nnames\n```\n\n```{r}\n# If we want to access the first name, we can use brackets and the position of the name in the vector:\nnames[1]\n```\n\n```{r}\n# This works with any position, for example the third name:\nnames[3]\n\n# You can index more than one position at a time too:\nnames[c(1,2)]\n\n# Changing the order of numbers you supply changes the order of names returned\nnames[c(2,1)]\n```\n\n### Working with data frames\n\nThis works for two-dimensional structures too, like data frames and matrices. We'd just format it as: `dataframe[row,column]`. Let's try it out:\n\n```{r}\n# Make a data frame\ndf <- data.frame(\n  name = c(\"Rosalind Franklin\", \"Marie Curie\", \"Barbara McClintock\", \"Ada Lovelace\", \"Dorothy Hodgkin\", \n           \"Lise Meitner\", \"Grace Hopper\", \"Chien-Shiung Wu\", \"Gerty Cori\", \"Katherine Johnson\"),\n  field = c(\"DNA X-ray crystallography\", \"Radioactivity\", \"Genetics\", \"Computer Programming\", \"X-ray Crystallography\", \n            \"Nuclear Physics\", \"Computer Programming\", \"Experimental Physics\", \"Biochemistry\", \"Orbital Mechanics\"),\n  school = c(\"Cambridge\", \"Sorbonne\", \"Cornell\", \"University of London\", \"Oxford\", \n             \"University of Berlin\", \"Yale\", \"Princeton\", \"Washington University\", \"West Virginia University\"),\n  date_of_birth = c(\"1920-07-25\", \"1867-11-07\", \"1902-06-16\", \"1815-12-10\", \"1910-05-12\", \n                    \"1878-11-07\", \"1906-12-09\", \"1912-05-31\", \"1896-08-15\", \"1918-08-26\"),\n  working_region = c(\"Western Europe\", \"Western Europe\", \"North America\", \"Western Europe\", \"Western Europe\", \"Western Europe\", \"North America\", \"North America\", \"North America\",  \"North America\")\n)\n\n# To get the first row:\ndf[1,]\n\n# or the first column: \ndf[,1]\n\n# for specific cells: \ndf[2,3]\n\n# We can use the column name instead of numbers:\ndf[2,\"school\"]\n\n# We can do the same thing by using a dollar sign:\ndf$name\n\n# We can also give a list of columns\n# which return in the order provided\ndf[,c(\"school\",\"name\")]\n```\n\n### Standard data formats and Tidy\n\nThat data, and most two-dimensional data sets (data frames, matrices, etc.) is often organized the similarly:\n\n-   Each variable is its own column\n\n-   Each observation is its own row\n\n-   Each value is a single cell.\n\n```{r tidy_style,echo=FALSE, fig.align = 'center', out.width = \"100%\", fig.cap = \"Source: Hadley Wickhamâ€™s R for Data Science, 1st Edition\"}\nknitr::include_graphics(\"wrangling-files/tidy-style.png\")\n```\n\nThis follows the *tidy data* style, an approach to handling data in R that aims to be clear and readable.\n\n::: {.callout-note title=\"Tidiest Universe\"}\nThe bundle of tidy-associated packages is called the `tidyverse`, and it's a ðŸ”¥ hot-topic ðŸ”¥ in the R world. In fact, `ggplot` is a package that you have already used that is part of the `tidyverse`! Most data wrangling problems can be solved with `tidy` or base (default) R functions. This can lead to some headaches for beginners, as there are multiple ways to accomplish the same thing!\n:::\n\n### `dplyr` verbs\n\nOne of the most popular `tidyverse` packages, `dplyr`, offers a suite of helpful and readable functions for data manipulation. Let's get started with how it can help you see your data:\n\n```{r}\n#| echo: false\n#| warning: false\nlibrary(dplyr)\nlibrary(tidyr)\n```\n\n```{r}\ndplyr::glimpse(df)\n```\n\nWith the `glimpse` function we see that this is a data frame with 3 observations and 3 variables. We can also see the type of each variable and the first few values.\n\n::: callout-tip\n`dplyr` functions have a lot in common:\n\n-   The first argument is always a data frame\n\n-   The following arguments typically specify which columns to operate on, using the variable names (without quotes)\n\n-   The output is always a new data frame\n:::\n\n```{r dplyr_syntax,echo=FALSE, fig.align = 'center', out.width = \"100%\", fig.cap = \"Source: Joshua Ebnerâ€™s A Quick Introduction to Dplyr\"}\nknitr::include_graphics(\"wrangling-files/dplyr_syntax.png\")\n```\n\nThe `dplyr` package has a set of functions that are used to manipulate data frames (you may see these referred to as \"verbs\", and it may also be helpful to think of them as verbs performing an action on your dataframe). These functions can either act on rows (e.g. `filter` out specific rows by some condition) or columns (e.g. `select` columns XYZ). There are also functions for working with groups (e.g. group rows by what values they have in a column with `group_by`).\n\n::: panel-tabset\n## rows\n\nThe most important verbs that operate on rows of a dataset are `filter()`, which changes which rows are present without changing their order, and `arrange()`, which changes the order of the rows without changing which are present. Both functions only affect the rows, and the columns are left unchanged. We'll also discuss `distinct()` which finds rows with unique values but unlike `arrange()` and `filter()` it can also optionally modify the columns.\n\nMore information about functions like this can be found [here](https://r4ds.hadley.nz/data-transform#rows).\n\n## columns\n\nThere are four important verbs that affect the columns without changing the rows: `mutate()` creates new columns that are derived from the existing columns, `select()` changes which columns are present, `rename()` changes the names of the columns, and `relocate()` changes the positions of the columns.\n\nMore information about functions like this can be found [here](https://r4ds.hadley.nz/data-transform#columns).\n\n## groups\n\n`group_by` allows you to create groups using more than one variable.\n\n`summarize` works on grouped objects and allows you to calculate a single summary statistic, reducing the data frame to have a single row for each group.\n\nThe `slice` family of functions allows you to extract specific rows within each group\n\nMore information about functions like this can be found [here](https://r4ds.hadley.nz/data-transform#groups).\n:::\n\n::: callout-tip\n`dplyr` verbs work great as a team!\n:::\n\nAlthough these were basic examples, hopefully you feel a little more confident about working with vectors, and data frames using `dplyr` verbs to clean and manipulate data. Happy Wrangling!\n\n### Functions on functions\n\n#### An introduction to pipes\n\nData scientists often want to make many changes to their data at one time. Typically, this means using more than one function at once. However, the way we've been writing our scripts so far would make for some very confusing looking code.\n\nFor example, let's use `dplyr` functions to perform two operations on our data set of scientists: filter for those born after 1900 and then arrange them by date of birth.\n\n::: panel-tabset\n## Writing it as separate steps\n\nHere we first filter and then arrange. Note that we are creating an intermediate variable in between the steps.\n\n```{r}\n# Filtering for scientists born after 1900\nfiltered_data <- filter(df, as.Date(date_of_birth) > as.Date(\"1900-01-01\"))\n\n# Arranging the filtered data by date of birth\narranged_data <- arrange(filtered_data, date_of_birth)\n```\n\n## Combining functions in one line\n\nWe can do the same thing without creating an intermediate variable. It's more compact but can start to get confusing if we add more functions.\n\n```{r}\narranged_data <- arrange(filter(df, as.Date(date_of_birth) > as.Date(\"1900-01-01\")), date_of_birth)\n```\n\n## Using pipes to clean up the code\n\nThe **pipe operator**, `|>`, is a tool that can help make the script more readable. It allows us to pass the result of one function directly into the next. Think of it as saying, \"and then..\"\n\nLet's dissect our goal: *filter for those born after 1900* **and then** *arrange them by date of birth*.\n\n`filter` is doing the *filter for...* part\n\n`arrange` is doing the *arrange them...* part\n\nand the pipe, `|>`, is going to do the **and then...** part.\n\n```{r}\n# Using pipes\narranged_data <- df |>\n  filter(as.Date(date_of_birth) > as.Date(\"1900-01-01\")) |>\n  arrange(date_of_birth)\n```\n\nOnce you're comfortable with this style, you should be able to read it as: Take `data` *and then* `filter` by DoB *and then* `arrange` by DoB. This helps keep our code both clean and readable.\n:::\n\n::: callout-tip\nThere are two pipe operators: `|>` and `%>%`. They work almost the exact same way. `%>%` is from the `magrittr` package and was the only way to pipe before version R 4.1.0. You may see `%>%`more frequently in code from previous lab members.\n\n::: {.callout-note title=\"Placeholders\" collapse=\"true\"}\nThe **Placeholder** operator allows more control over where the `LHS` (left hand side) is placed into the `RHS` (right hand side) of the pipe operator.\n\n::: panel-tabset\n#### `%>%`\n\n`%>%` uses `.` as its placeholder operator. In addition to this, you may use `.` multiple times on the `RHS`\n\n```{r}\n3 %>% head(x = letters, n = .)\n3 %>% sum(2, ., .)\n```\n\n#### `|>`\n\n`|>` uses `_` as its placeholder operator. However, the `_` placeholder must only be used once and the argument must be named\n\n```{r}\n3 |> head(x = letters, n = _)\n```\n\n```{r}\n#| error: true\n3 |> sum(2, _)\n```\n\n```{r}\n#| error: true\nadd3 <- function(x, y, z) x + y + z\n3 |> add3(2, y = _, z = _)\n```\n:::\n:::\n\n::: {.callout-note title=\"Right Hand Side (RHS)\" collapse=\"true\"}\n::: panel-tabset\n#### `%>%`\n\n`%>%` can take a function name on the `RHS`\n\n```{r}\nletters %>% head\n```\n\n#### `|>`\n\nThe `RHS` for `|>` must be a function with `()`\n\n```{r}\n#| error: true\nletters |> head\n```\n\n```{r}\nletters |> head()\n```\n:::\n:::\n\n::: {.callout-note title=\"Anonymous Functions\" collapse=\"true\"}\n::: panel-tabset\n#### `%>%`\n\n`%>%` can take expressions in curly braces `{}`\n\n```{r}\nx <- 10\n5 %>% {x + .}\n```\n\n#### `|>`\n\n`|>` must have a function call on `RHS`\n\n```{r}\n#| error: true\nx <- 10\n5 |> {x + _}\n```\n\n```{r}\n5 |> {function(y) x + y}()\n```\n:::\n:::\n\nTo summarize, `%>%` is slightly more lenient than `|>` when it comes to the Placeholder operator, the Right Hand Side (RHS) and Anonymous functions.\n:::\n\n## Case Study Introduction\n\nJust reading about ways to manipulate data can be hard to understand without an application. Since this course is geared towards biomedical sciences, we thought you might find it easier if we work through an actual research data set.\n\nFor this example, we have some data from an experiment that measured the proportions of different cell times within mouse cardiac tissue. These samples are from treatment vs. control and WT (wild type) vs. mutant.\n\nWhat are some things that we, as researchers, would want to know about our data?\n\n-   Did the experiment work?\n\n::: {.callout-note title=\"Things to consider:\"}\nCheck your controls or expected features!\n:::\n\n-   Do we see differences between our experimental groups?\n\nTo get at these questions, we need to be able to manipulate our data into the formats needed to check those features and for plotting. To start, lets take a look at how the results are structured before we start planning how to do the processing.\n\n### Getting familiar with the data\n\n```{r}\noptions(digits = 3)\n# Load the data. The sample IDs were stored as the first row, so lets make those the row.names\ncell_props <- read.csv(\"wrangling-files/cellProportions.csv\",\n                       row.names = 1)\n\nhead(cell_props)\n```\n\n::: {.callout-note title=\"Whole vs. Fractions\"}\n`Fraction` samples are our controls. They are supposed to be almost completely one single cell type. They're just here to make sure we accurately measured cell type proportions.\n\n`Whole` samples are our test samples. They're from the treatment/control mice, which you'd expect to have a range of cell types.\n:::\n\n### Analysis Goals\n\nFor next class, you should brainstorm some ideas for how to approach the analysis. Try to consider these angles:\n\n-   What do we want to know about this data set?\n-   What kind of visuals would we want to make to check that?\n-   What would the data need to look like to get those visuals?\n-   How does the data look now?\n-   Which functions might we use to get the data from its current state to what we need for plotting?\n\nIn the beginning of next class, we'll chat about what ideas you had!\n\n(Ambitious students who want to try before then will also need the phenotype data located at `wrangling-files/cellPhenotypes.csv`)\n"},"formats":{"html":{"execute":{"fig-width":7,"fig-height":5,"fig-format":"retina","fig-dpi":96,"df-print":"default","error":false,"eval":true,"cache":true,"freeze":"auto","echo":true,"output":true,"warning":true,"include":true,"keep-md":false,"keep-ipynb":false,"ipynb":null,"enabled":null,"daemon":null,"daemon-restart":false,"debug":false,"ipynb-filters":[],"engine":"knitr"},"render":{"keep-tex":false,"keep-source":false,"keep-hidden":false,"prefer-html":false,"output-divs":true,"output-ext":"html","fig-align":"default","fig-pos":null,"fig-env":null,"code-fold":"none","code-overflow":"scroll","code-link":false,"code-line-numbers":false,"code-tools":false,"tbl-colwidths":"auto","merge-includes":true,"latex-auto-mk":true,"latex-auto-install":true,"latex-clean":true,"latex-max-runs":10,"latex-makeindex":"makeindex","latex-makeindex-opts":[],"latex-tlmgr-opts":[],"latex-input-paths":[],"latex-output-dir":null,"link-external-icon":false,"link-external-newwindow":false,"self-contained-math":false,"format-resources":[]},"pandoc":{"standalone":true,"wrap":"none","default-image-extension":"png","to":"html","number-sections":false,"toc":true,"toc-depth":4,"output-file":"class5.html"},"language":{},"metadata":{"lang":"en","fig-responsive":true,"quarto-version":"1.2.269","editor":"visual","theme":"cosmo","title":"Data Wrangling Basics","subtitle":"Data Wrangling Day 1","author":"Brian Gural, Lorrie He, Justin Landis, JP Flores"},"extensions":{"book":{"multiFile":true}}},"pdf":{"execute":{"fig-width":5.5,"fig-height":3.5,"fig-format":"pdf","fig-dpi":300,"df-print":"default","error":false,"eval":true,"cache":true,"freeze":"auto","echo":true,"output":true,"warning":true,"include":true,"keep-md":false,"keep-ipynb":false,"ipynb":null,"enabled":null,"daemon":null,"daemon-restart":false,"debug":false,"ipynb-filters":[],"engine":"knitr"},"render":{"keep-tex":false,"keep-source":false,"keep-hidden":false,"prefer-html":false,"output-divs":true,"output-ext":"pdf","fig-align":"default","fig-pos":null,"fig-env":null,"code-fold":"none","code-overflow":"scroll","code-link":false,"code-line-numbers":false,"code-tools":false,"tbl-colwidths":true,"merge-includes":true,"latex-auto-mk":true,"latex-auto-install":true,"latex-clean":true,"latex-max-runs":10,"latex-makeindex":"makeindex","latex-makeindex-opts":[],"latex-tlmgr-opts":[],"latex-input-paths":[],"latex-output-dir":null,"link-external-icon":false,"link-external-newwindow":false,"self-contained-math":false,"format-resources":[]},"pandoc":{"pdf-engine":"xelatex","standalone":true,"variables":{"graphics":true,"tables":true},"default-image-extension":"pdf","to":"pdf","output-file":"class5.pdf"},"language":{},"metadata":{"block-headings":true,"editor":"visual","documentclass":"scrreprt","title":"Data Wrangling Basics","subtitle":"Data Wrangling Day 1","author":"Brian Gural, Lorrie He, Justin Landis, JP Flores"},"extensions":{"book":{}}}}}