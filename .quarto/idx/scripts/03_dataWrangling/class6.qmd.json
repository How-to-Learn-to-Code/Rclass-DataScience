{"title":"Data Wrangling with Real Experimental Data","markdown":{"yaml":{"title":"Data Wrangling with Real Experimental Data","subtitle":"Data Wrangling, Day 2","author":"Brian Gural, Lorrie He, JP Flores","format":{"html":{"toc":true}},"execute":{"freeze":true}},"headingText":"Objectives of Data Wrangling: Class 2","containsRefs":false,"markdown":"\n\n```{r, echo=FALSE}\noptions(digits = 3)\n```\n\n\n-   Be able to apply the objectives covered in Data Wrangling: Class 1 to a new dataset\n\n## Case Study\n\nLast class, we had introduced a dataset/experiment that we would work through. Let's remind ourselves of some of the details:\n\n-   We have proportions of cell types across samples\n-   There controls made of mostly pure cell types (`fractions`) and experimental samples (`whole`)\n-   There are `.csv` files for both the cell type proportion data and the sample phenotypes\n\nThere are a few things to think about when wrangling/exploring data:\n\n-   What do you want to know about this data?\n-   What kind of visuals would you want to make?\n-   How does the data need to be formatted to get those visuals?\n-   What are some expected features of our data?\n\nTake a moment to talk among yourselves about this/any ideas you had since last class!\n\n### Getting familiar with the data\n\n#### Proportions Data\n\n```{r}\n# Load the data. The sample IDs were stored as the first row, so lets make those the row.names\ncell_props <- read.table(\"wrangling-files/cellProportions.csv\",\n                       row.names = 1, header = TRUE, sep = \",\")\n\nhead(cell_props)\n```\n\n::: callout-tip\nOur data fits the `tidy` style, since each row is a sample (observation) and each column is a different cell type (variable).\n:::\n\nWhen assessing data, it's good to *consider what features you'd expect from a given data set*. This helps you know if something has gone wrong before you've gotten your hands on it.\n\nWe're looking at the proportion of cell types in each sample, which should sum up to 1. Checking that the values in each row add to 1 would help confirm that we have what we're expecting:\n\n```{r}\nrowSums(cell_props)\n```\n\n::: callout-tip\nRaw RNA-seq matrices should go up to 100,000s. So if you only see small numbers in the data, it's likely been manipulated in some way.\n:::\n\n#### Phenotype data\n\nWe also have the phenotypes for the samples in a separate file:\n\n```{r}\ncell_phenos <- read.table(\"wrangling-files/cellPhenotypes.csv\",\n                        row.names = 1,sep = \",\",header = TRUE)\n\nstr(cell_phenos)\n```\n\n\"\n\n### Planning the analysis\n\nWe want to know:\n\n-   If the controls look as we'd expect\n-   What group differences there are\n\nTo get at the question about controls, we'd need to check `cell_phenos` to see which samples are from the control or experimental groups. After, we'll plot the proportions.\n\n```{mermaid}\nflowchart LR\nA[Data frame of\\n cell proportions] --> C(Merged proportions\\n and phenotypes)\nB[Data frame of\\n sample phenotypes]  --> C\nC --> D{Steps to get data\\nformatted for plotting}\nD --> E[Plot of control samples]\nD --> F[Plot of experiment samples]\n```\n\n### Manipulating data frames\n\n#### Summarizing and subsetting\n\nLet's get more context on what's in the data. `table` is a convenient way to summarize columns and lists:\n\n```{r}\n# What unique values and how many of each are in the \"genotype\" field\ntable(cell_phenos$genotype)\n# Table can also compare two variables. useNA need to be added to include cells with NAs\ntable(cell_phenos$type, cell_phenos$genotype,  useNA = \"ifany\")\n```\n\nSeems that the purified cell types list NA for their genotype and that there are three types. Also, we have 8 knock-outs and 8 are wild type.\n\n#### Combining and reordering\n\nData frames can be combined in a bunch of ways, but no matter the method [it is essential that the order of samples match]{.underline}. R has two built-in methods, binds (`cbind` and `rbind`) and `merge`.\n\n```{r captain_planet_gif,echo=FALSE, fig.align = 'center', out.width = \"80%\", fig.cap = \"Captain Planet and the Planeteers likely combined using merge functions\"}\nknitr::include_graphics(\"wrangling-files/captain-planet.gif\")\n```\n\nBinds slap two data frames together. `cbind` adds columns, `rbind` adds rows. Binds don't consider the order of the data sets, so there's a risk of things being out of order.\n\n`merge` is similar to `cbind`, but matches the data sets based on a common column.\n\n##### `cbind`\n\n```{r}\n# bind the rownames to see if they match\ncbind(rownames(cell_phenos), rownames(cell_props)) |> head()\n\n```\n\nAbove, you can see that `cbind` would mismatch the samples. **Always be careful when using `cbind`! It has no guardrails for ordering!**\n\n```{r}\n# Reorder one to match the other\n# This uses the cell_phenos rownames as a list to specify the order of indices \ncell_props <- cell_props[rownames(cell_phenos),]\n\n# They should all be TRUE now\nall(rownames(cell_phenos) == rownames(cell_props))\n\n# Now we can merge them \ndata_bind <- cbind(cell_phenos, cell_props)\n\nhead(data_bind)\n```\n\n##### `merge`\n\n```{r}\n# Specify row.names as the feature to merge by\ndata_merge <- merge(cell_phenos, cell_props, by = \"row.names\")\n\nhead(data_merge)\n```\n\nWhile this won't always be the case with `merge` vs. `bind`, its better to use `merge` in this scenario, since it helps keep your script *interpretable.*\n\n::: {.callout-note title=\"Reproducible code\"}\nIf you continue with programming, you'll need to share your code or return to code you wrote months ago. Writing easy-to-understand scripts gives you less headache later!\n:::\n\n### Preparing for different visualizations\n\nAt this point, we should ask ourselves a few questions:\n\n-   What am I trying to see about the data?\n-   What kind of plot helps us see that?\n\nTake a minute to talk as a group about how you would visualize the data!\n\n**What am I trying to see about the data?**\n\nOur samples have data on the proportions of many cell types. I'd want to easily compare all of these cell types at once, with samples/groups side-by-side.\n\n**What kind of plot do we want?**\n\nPie charts are often used to visualize percents/proportions, but its difficult to see differences between two pie charts. A stacked bar plot would be a better fit, since we're trying to compare different sample groups.\n\n**What format does my data need to be to make said plot?**\n\nThis stacked bar plot would have:\n\n-   Samples on the X-axis\n\n-   Cell-type proportions on the Y-axis\n\n-   Colors for each cell type in each bar\n\nFor `ggplot` to make this our data needs to have a column for each term, but the data is spread across many columns. To solve this, we first need to understand the concepts of wide and long data.\n\n#### Pivoting wide and long\n\nData is often formatted as *wide* or *long*. Our data is in a wide format, which has a single row for each sample and a column for each variable. When wide data is pivoted into a long format columns are condensed together.\n\n```{r ross_gif,echo=FALSE, fig.align = 'center', out.width = \"80%\", fig.cap = \"Ross understands the importance of converting wide and long data\"}\nknitr::include_graphics(\"wrangling-files/pivot.gif\")\n```\n\nIt's easiest to understand how pivoting works in visuals:\n\n::: panel-tabset\n## Still images\n\n```{r pivot_still,echo=FALSE, fig.align = 'center', out.width = \"100%\", fig.cap = \"Source: Garrick Aden-Buie’s (@grrrck) Tidy Animated Verbs github.com/gadenbuie/tidyexplain\"}\nknitr::include_graphics(\"wrangling-files/tidyr_pivot.png\")\n```\n\n## Animated transition\n\n```{r pivot_gif,echo=FALSE, fig.align = 'center', out.width = \"100%\", fig.cap = \"Source: Garrick Aden-Buie’s (@grrrck) Tidy Animated Verbs github.com/gadenbuie/tidyexplain\"}\nknitr::include_graphics(\"wrangling-files/tidyr-pivoting.gif\")\n```\n:::\n\nAs a reminder, we want to make a **column of proportions values** (val) and a **column specifying cell types** (key).\n\n```{r}\nlibrary(tidyverse)\n# cell types are specified with cols = and name the new column with names_to\n# values originally in those columns are going to move to a new values column, which we can name with values_to =\ndata_long <- pivot_longer(data_merge, \n                          cols = c(Cardiomyocytes, Fibroblast, Endothelial.Cells, Macrophage, Pericytes.SMC), \n                          names_to = \"cell.type\", values_to = \"proportion\")\n\nstr(data_long)\n```\n\nWe have a couple of changes:\n\n-   There are two new columns, `cell.type` and `proportion`\n\n-   We have A LOT more rows than we did originally\n\n-   The sample IDs were coerced to a column \"Row.names\" that is an 'AsIs' character. We'll need to correct that before we plot the data\n\n#### Wrangling for plotting\n\n##### Pure cell-type fraction controls\n\nWith our data in this format, we can make a lot of cool plots. Lets start with the bar plot we had planned.\n\n```{r}\ndata_long |> \n  mutate(id = as.character(Row.names)) |> # fix the AsIs type\n  ggplot(aes(x = id, y = proportion, fill = cell.type))+\n  geom_bar(position=\"fill\", stat=\"identity\")\n```\n\n::: callout-tip\n`mutate` is a great way to modify specific parts of your data or make new columns!\n:::\n\nIt worked, but it looks... less than pleasing. Lets remind ourselves of what we wanted to see in the plot: groups side-by-side.\n\nI'd like to start by making a plot just for the controls for now. `filter` from the `dplyr` package will help separate the groups. Also, I'll make aesthetic changes to make it easier to compare groups and nicer to look at.\n\n```{r}\ndata_long |> \n  filter(type != \"whole_tissue\") |> \n  mutate(id = as.character(Row.names)) |> \n  ggplot(aes(x = id, y = proportion, fill = cell.type))+\n  geom_bar(position=\"fill\", stat=\"identity\", color = \"black\", width = 1) +\n  facet_grid(cols=vars(type), scales = \"free\") +\n  scale_fill_manual(values = c(\"#66C2A5\",\"#FC8D62\", \"#8DA0CB\", \"#E78AC3\", \"#A6D854\")) +\n  theme_minimal() +\n  theme(\n    axis.title.x = element_blank(), \n    legend.title = element_blank(),\n    legend.position = \"bottom\"\n  ) +\n  guides(x = guide_axis(angle = 45)) +\n  labs(title = \"Cell type proportions in purified control samples\",\n       y = \"Cell Type Proportion\")\n\n\n```\n\nThis looks good! We can see what we expected of our control samples. Each of the fractions are made up of a single cell type. Let's move onto the experimental samples.\n\n##### Experimental Samples\n\nThere are two things we should consider before we visualize differences between our experimental groups:\n\n-   It would be easier to compare shifts in specific cell types if we break up the stacked bar chart so that the cell types are spread across the x-axis.\n-   In our last plot, we compared samples across a single phenotypic factor: `type`. This time, it's more complicated because we want to we want to compare both `genotype` and `treatment`.\n\n```{r}\ndata_long   |> \n  filter(type == \"whole_tissue\") |> \n  ggplot(aes(x = cell.type, y = proportion)) +\n  geom_bar(stat = \"summary\", fun = mean, width = 0.9,  color = \"black\") +\n  facet_grid(genotype ~ treatment, scales = \"free\") + \n  theme_minimal() +\n  theme(\n    axis.title.x = element_blank(), \n    legend.title = element_blank(),\n    legend.position = \"bottom\"\n  ) +\n  labs(y = \"Estimated Proportion\") +\n  scale_fill_manual(values = c(\"#66C2A5\",\"#FC8D62\", \"#8DA0CB\", \"#E78AC3\", \"#A6D854\")) +\n  guides(x = guide_axis(angle = 45))\n```\n\nWe just made three major changes:\n\n-   `cell.type` is on the x-axis, not sample `id`s\n-   We're plotting the **mean** of each cell type across many samples in each group. `geom_bar` can do this automatically with `stat = \"summary\", fun = mean,`\n-   We're showing four plots at once by having `facet_grid` contrast them with `genotype ~ treatment`\n\nHowever, it may still be tough to compare across the groups. Also, only showing the mean masks any variation within groups. Lets make two more major changes to fix that:\n\n-   Put all of the groups into a single plot\n-   Add dots for each sample onto each bar\n\nAnd to make it easier to read, let's reorder the X-axis by most to least abundant cell types.\n\n###### Reorder cell types\n\nWe can take advantage of `factors` to reorder, since `ggplot` references the order of factors when plotting.\n\n```{r}\n# Find the most-to-least abundant cell types\ncell.type.order <- data_long |> \n  filter(type == \"whole_tissue\") |> \n  group_by(cell.type) |> # Manipulate the data within cell-type groups\n  mutate(mean = mean(proportion)) |> # make a new column that is the mean of the proportions \n  arrange(desc(mean)) |> # arrange by mean proportion\n  pull(cell.type) |> # pull out the cell type column as a list\n  unique() # remove duplicated values\ncell.type.order\n```\n\n###### Put all groups on a single plot\n\nIf we combine `genotype` and `treatment` into a single variable, we can condense down to a single plot. While we're at it, we can apply `cell.type.order` to make the `data_long$cell.type` into a factor-level column:\n\n```{r}\ndata_long <- data_long |> \n  mutate(cell.type = factor(cell.type, levels = cell.type.order),\n         Genotype_Treatment = factor(paste(genotype, \"-\", treatment), levels = c(\"WT - Sham\", \"WT - MI\", \"cmAKO - Sham\", \"cmAKO - MI\")))\n```\n\n###### Plot\n\n```{r}\n# Generate boxplot\ndata_long  |> \n  filter(type == \"whole_tissue\") |> \n  ggplot(aes(x = cell.type, y = proportion, fill = Genotype_Treatment)) +\n  geom_bar(stat = \"summary\", fun = mean, width = 0.9,  color = \"black\",\n           position = position_dodge(0.9)) +\n  geom_jitter(inherit.aes = T, \n              position = position_dodge(0.9),\n              size = 2, alpha = 0.3) +\n  labs(y = \"Estimated Proportion\", \n       fill = \"Treatment\") +\n  theme(\n    axis.title.x = element_blank(), \n    legend.title = element_blank(),\n    legend.position = \"bottom\"\n  ) +\n  scale_fill_manual(values = c(\"#A6CEE3\", \"#1F78B4\", \"#FDBF6F\", \"#FF7F00\")) +\n  guides(x = guide_axis(angle = 45))\n\n```\n"},"formats":{"html":{"execute":{"fig-width":7,"fig-height":5,"fig-format":"retina","fig-dpi":96,"df-print":"default","error":false,"eval":true,"cache":true,"freeze":true,"echo":true,"output":true,"warning":true,"include":true,"keep-md":false,"keep-ipynb":false,"ipynb":null,"enabled":null,"daemon":null,"daemon-restart":false,"debug":false,"ipynb-filters":[],"engine":"knitr"},"render":{"keep-tex":false,"keep-source":false,"keep-hidden":false,"prefer-html":false,"output-divs":true,"output-ext":"html","fig-align":"default","fig-pos":null,"fig-env":null,"code-fold":"none","code-overflow":"scroll","code-link":false,"code-line-numbers":false,"code-tools":false,"tbl-colwidths":"auto","merge-includes":true,"latex-auto-mk":true,"latex-auto-install":true,"latex-clean":true,"latex-max-runs":10,"latex-makeindex":"makeindex","latex-makeindex-opts":[],"latex-tlmgr-opts":[],"latex-input-paths":[],"latex-output-dir":null,"link-external-icon":false,"link-external-newwindow":false,"self-contained-math":false,"format-resources":[]},"pandoc":{"standalone":true,"wrap":"none","default-image-extension":"png","to":"html","number-sections":false,"toc":true,"toc-depth":4,"output-file":"class6.html"},"language":{},"metadata":{"lang":"en","fig-responsive":true,"quarto-version":"1.2.269","editor":"visual","theme":"cosmo","title":"Data Wrangling with Real Experimental Data","subtitle":"Data Wrangling, Day 2","author":"Brian Gural, Lorrie He, JP Flores"},"extensions":{"book":{"multiFile":true}}},"pdf":{"execute":{"fig-width":5.5,"fig-height":3.5,"fig-format":"pdf","fig-dpi":300,"df-print":"default","error":false,"eval":true,"cache":true,"freeze":true,"echo":true,"output":true,"warning":true,"include":true,"keep-md":false,"keep-ipynb":false,"ipynb":null,"enabled":null,"daemon":null,"daemon-restart":false,"debug":false,"ipynb-filters":[],"engine":"knitr"},"render":{"keep-tex":false,"keep-source":false,"keep-hidden":false,"prefer-html":false,"output-divs":true,"output-ext":"pdf","fig-align":"default","fig-pos":null,"fig-env":null,"code-fold":"none","code-overflow":"scroll","code-link":false,"code-line-numbers":false,"code-tools":false,"tbl-colwidths":true,"merge-includes":true,"latex-auto-mk":true,"latex-auto-install":true,"latex-clean":true,"latex-max-runs":10,"latex-makeindex":"makeindex","latex-makeindex-opts":[],"latex-tlmgr-opts":[],"latex-input-paths":[],"latex-output-dir":null,"link-external-icon":false,"link-external-newwindow":false,"self-contained-math":false,"format-resources":[]},"pandoc":{"pdf-engine":"xelatex","standalone":true,"variables":{"graphics":true,"tables":true},"default-image-extension":"pdf","to":"pdf","output-file":"class6.pdf"},"language":{},"metadata":{"block-headings":true,"editor":"visual","documentclass":"scrreprt","title":"Data Wrangling with Real Experimental Data","subtitle":"Data Wrangling, Day 2","author":"Brian Gural, Lorrie He, JP Flores"},"extensions":{"book":{}}}}}