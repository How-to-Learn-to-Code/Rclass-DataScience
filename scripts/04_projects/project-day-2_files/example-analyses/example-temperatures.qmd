---
title: "Example Analysis: Temperatures"
date: "today"
format: 
  html:
    toc: true
---

# Preamble

This script will loosely follow the template document: it is more meant for you to get an idea of one way to approach the data processing and visualization! This analysis will primarily focus on using tidyverse tools (i.e. `dplyr` and `ggplot`).

------------------------------------------------------------------------

For this dataset, the **main skills** we want you to practice are:

1.  Parsing strings: `Subject.ID` and `period` contain some valuable information that once parsed out, can make your analyses much more informative.
2.  Working with `NA` values: these can break code in unexpected ways, particularly when working with numeric data.

The **research questions** we will address are:

1.  Easier: How many participants were there for each neighborhood in the study?
2.  Harder: What was the daily average temperature for each neighborhood during the study period?

# 1. Load data and libraries

```{r}
library(tidyverse)

temps <- read.csv("~/Desktop/Rclass-DataScience/scripts/04_projects/project-day-2_files/datasets/temperatures.csv", header = TRUE, sep = ",")
```

# 2. Format the Data

## Skill: Parsing strings

There is useful information that is contained within the `Subject.ID` and `period` columns that would be nice to extract out. There are a few handy functions from the `stringr` package within the tidyverse that we can use (look up `??stringr::stringr` for an overview of the package). In particular, we'll use `str_sub()` to tackle splitting the `Subject.ID` and `str_split_fixed()` to tackle the `period` information.

`Subject.ID` has no actual delimiters aside from the positions of the data (neighborhood in the 1st, subject ID in the 2nd), so we'll use `str_sub()`. It needs to know which string we're working on and the start and end positions of where it should extract: since we only want one character, the start and end positions will be the same.

In contrast, `period` has 2 pieces of information (the day of the week and the hours) separated by the `", "` ("comma-space"). We'll use `str_split_fixed()`, which needs to know the string we're working on, the separator, and how many pieces of info are separated by that separator pattern. Since this function returns an entire matrix, we'll also specify which column of the matrix we want using our index operator (`[,]`).

```{r}
temps <- temps |>
  mutate(neighborhood = str_sub(Subject.ID, 1, 1),
         id = str_sub(Subject.ID, 2, 2),
         wkday = str_split_fixed(period, ", ", n = 2)[,1],
         hrs = str_split_fixed(period, ", ", n = 2)[,2])
```

## Skill: Working with `NA` values

There is nothing explicit we will do about `NA` values here for now – just keep them in mind and we'll handle them later when we visualize!

# 3. Visualize the Data

## Easier

::: callout-note
### Research question

How many participants were there for each neighborhood in the study?
:::

This question is "easier" to approach in the sense that there isn't much additional data wrangling to do: we just need to `summarize()` the data. There is a helpful counting function from dplyr, `n_distinct()`, that we can use count the unique number of subject `id`s. Since we are looking at count data, we can use a bar graph.

```{r}
# count participants
participants <- temps |>
  group_by(neighborhood) |>
  summarize(count = n_distinct(id))

# plot
ggplot(participants, aes(x = neighborhood, y = count)) +
  geom_col() +
  labs(title = "Study participants per neighborhood")
```

Let's add in the neighborhood names from the metadata to make this graph a little clearer. Since these are discrete values, we'll use `scale_x_discrete()` and specify the `labels` argument, which will make R rename the current x-axis labels with whatever you provide to the `labels` argument.

There are two ways to tell R what your new label values are:

1.  `labels = c("old_value1" = "new_value1", "old_value2" = "new_value2")`
2.  `labels = c("new_value1", "new_value2")`

::: {.callout-note collapse="true"}
### How does the second method work?

If using the latter method, how does R know what to assign to what? (e.g. how to assign "1" to "Coffelt", etc?)

Simply, R assumes you're specifying the new values in the same order as the old values. To check the order of the old values, you can use the `levels()` and `as.factor()` functions like so: `levels(as.factor(df$variable))`
:::

```{r}
# double-check the order
levels(as.factor(temps$neighborhood))

# better labels
ggplot(participants, aes(x = neighborhood, y = count)) +
  geom_col() +
  labs(title = "Study participants per neighborhood") +
  scale_x_discrete(labels = c("Coffelt", "Encanto-Palmcroft", "Garfield", "Thunderhill", "Power Ranch"))
```

## Harder

::: callout-note
### Research question

What was the daily average temperature for each neighborhood during the study period?
:::

Since we know the figures look better with the proper neighborhood names, let's replace them in our dataset first, before doing more analysis. There is a very handy dplyr function, `case_when()`, that works of like an `if_else()` statement, where you can specify certain things to happen depending on if a certain condition is `TRUE` or `FALSE`.

The general usage is as so: `case_when(<condition> ~ <result>)`. This function is convenient since you only need to think about a specific `<condition>` you need to get a certain `<result>`, and you don't necessarily need to address the other possible outcomes. This function is especially useful if you want to `mutate()` specific variables that depend on a complex set of criteria.

```{r}
# relabel neighborhoods
temps <- temps |>
  mutate(neighborhood = case_when(neighborhood == 1 ~ "Coffelt",
                                  neighborhood == 2 ~ "Encanto-PalmCroft",
                                  neighborhood == 3 ~ "Garfield", 
                                  neighborhood == 4 ~ "Thunderhill", 
                                  neighborhood == 5 ~ "Power Ranch"))
```

Now, we'll calculate the average temperature for each day of the week. Again, we'll use `summarize()`, and then check our math.

```{r}
# calculate avg daily temps for each neighborhood
dailyavg <- temps |>
  group_by(neighborhood, wkday) |>
  summarize(avgtemp = mean(temperature))

dailyavg
```

We can see we've gotten a lot of `NA` values! This is because not every `temperature` has a value: we'll account for this by using the `na.rm = TRUE` argument.

```{r}
# redo math
dailyavg <- temps |>
  group_by(neighborhood, wkday) |>
  summarize(avgtemp = mean(temperature, na.rm = TRUE))

dailyavg
```

This looks better! Now we can plot: a line graph probably makes sense, if we want to look at changes over the days of the week. Since we have so many variables (e.g. neighborhood and day of the week), R will have a hard time telling what points to connect, so we'll also specify the `group` argument in `aes()`.

```{r}
# plot
ggplot(dailyavg, aes(x = wkday, y = avgtemp, color = neighborhood, group = neighborhood)) +
  geom_line() + geom_point() +
  labs(title = "Average daily IETs of Pheonix, AZ neighborhoods", x = "Day of the week", y = "Average temperature (°C)")
```

We can see that our days of the week don't look quite right... R is doing the "sensible" thing and listening them in alphabetical order, but we can specify the weekday order by using `factor()` and specifying the `levels` argument.

```{r}
# reorder days of the week
dailyavg$wkday <- factor(dailyavg$wkday, levels = c("Mon", "Tue", "Wed", "Thu", "Fri", "Sat", "Sun"))

# plot again
ggplot(dailyavg, aes(x = wkday, y = avgtemp, color = neighborhood, group = neighborhood)) +
  geom_line() + geom_point() +
  labs(title = "Average daily IETs of Pheonix, AZ neighborhoods", x = "Day of the week", y = "Average temperature (°C)")
```

------------------------------------------------------------------------

# Code only

::: {.callout-note collapse="true"}
## Code only

```{r eval=FALSE}
# read in data, load libraries
library(tidyverse)

temps <- read.csv("~/Desktop/Rclass-DataScience/scripts/04_projects/project-day-2_files/datasets/temperatures.csv", header = TRUE, sep = ",")

# wrangle
## parse out the subject and period data
temps <- temps |>
  mutate(neighborhood = str_sub(Subject.ID, 1, 1),
         id = str_sub(Subject.ID, 2, 2),
         wkday = str_split_fixed(period, ", ", n = 2)[,1],
         hrs = str_split_fixed(period, ", ", n = 2)[,2])

# plot
## easier: plot participant counts
### count participants
participants <- temps |>
  group_by(neighborhood) |>
  summarize(count = n_distinct(id))

### initial plot
ggplot(participants, aes(x = neighborhood, y = count)) +
  geom_col() +
  labs(title = "Study participants per neighborhood")

### double-check neighborhoods
levels(as.factor(temps$neighborhood))

### plot with better labels
ggplot(participants, aes(x = neighborhood, y = count)) +
  geom_col() +
  labs(title = "Study participants per neighborhood") +
  scale_x_discrete(labels = c("Coffelt", "Encanto-Palmcroft", "Garfield", "Thunderhill", "Power Ranch"))


## harder: plot daily avg temps
### relabel neighborhoods
temps <- temps |>
  mutate(neighborhood = case_when(neighborhood == 1 ~ "Coffelt",
                                  neighborhood == 2 ~ "Encanto-PalmCroft",
                                  neighborhood == 3 ~ "Garfield", 
                                  neighborhood == 4 ~ "Thunderhill", 
                                  neighborhood == 5 ~ "Power Ranch"))

### calculate avg daily temps for each neighborhood
dailyavg <- temps |>
  group_by(neighborhood, wkday) |>
  summarize(avgtemp = mean(temperature, na.rm = TRUE))

### reorder days of the week
dailyavg$wkday <- factor(dailyavg$wkday, levels = c("Mon", "Tue", "Wed", "Thu", "Fri", "Sat", "Sun"))

### plot
ggplot(dailyavg, aes(x = wkday, y = avgtemp, color = neighborhood, group = neighborhood)) +
  geom_line() + geom_point() +
  labs(title = "Average daily IETs of Pheonix, AZ neighborhoods", x = "Day of the week", y = "Average temperature (°C)")

```
:::
